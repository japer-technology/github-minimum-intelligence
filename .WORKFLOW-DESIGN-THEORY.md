# Workflow Design Theory

> An analysis of the GitHub Actions workflows defined in this repository, their effects, and the architectural principles they embody.

---

## Workflows Overview

This repository defines three workflow files. Two are identical (one is the live workflow, the other is an install template), and one handles GitHub App installation events.

| Workflow | Location | Trigger |
|----------|----------|---------|
| [Agent Workflow](#1-agent-workflow) | `.github/workflows/github-minimum-intelligence-agent.yml` | `issues.opened`, `issue_comment.created` |
| [Agent Workflow (Template)](#2-agent-workflow-template) | `.github-minimum-intelligence/install/github-minimum-intelligence-agent.yml` | Same as above (copied during installation) |
| [Installation Workflow](#3-installation-workflow) | `.github-minimum-intelligence/install/github-minimum-intelligence-installation.yml` | `installation.created`, `installation_repositories.added` |

---

## 1. Agent Workflow

**File:** `.github/workflows/github-minimum-intelligence-agent.yml`

### Trigger Design

```yaml
on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]
```

**Effect:** The workflow activates on exactly two events â€” when a new issue is opened, or when a comment is posted on any issue. This turns every GitHub issue into a bidirectional conversation channel. The user writes; the agent reads, processes, and replies. By scoping to `opened` (not `edited` or `reopened`), the system avoids re-triggering on issue edits, which would cause duplicate responses.

### Concurrency Control

```yaml
concurrency:
  group: mi-issue-${{ github.event.issue.number }}
  cancel-in-progress: false
```

**Effect:** Each issue number gets its own concurrency group. If two comments arrive on the same issue in quick succession, the second run queues behind the first rather than running in parallel. The `cancel-in-progress: false` setting is critical â€” it ensures the first run completes its full cycle (agent reasoning, git commit, push, comment reply) before the second run begins. This prevents race conditions on session state files and git push conflicts within the same issue thread.

Runs on *different* issues execute in parallel with no interference, since their concurrency groups are distinct.

### Permissions

```yaml
permissions:
  contents: write
  issues: write
  actions: write
```

**Effect:** The workflow requests the minimum permissions required for its operations:

- **`contents: write`** â€” The agent commits session state, issue-to-session mappings, and any file edits back to the repository. Without write access to contents, the agent's memory model (git as storage) would not function.
- **`issues: write`** â€” The agent posts its reply as an issue comment and adds emoji reactions (ğŸš€, ğŸ‘, ğŸ‘) to signal status. Without this, the agent could think but not respond.
- **`actions: write`** â€” Required for the agent to interact with workflow run metadata and manage its own execution context.

### Step Pipeline

The workflow defines a single job (`run-agent`) with seven steps that form a pipeline:

#### Step 1: Authorize

```bash
PERM=$(gh api "repos/.../collaborators/.../permission" --jq '.permission')
if [[ "$PERM" != "admin" && "$PERM" != "maintain" && "$PERM" != "write" ]]; then
  exit 1
fi
```

**Effect:** Before any code runs, the workflow checks whether the actor (the person who opened the issue or posted the comment) has write-level access or above. This is the security gate. On public repositories, anyone can open an issue, but only collaborators can trigger the agent. This prevents unauthorized users from consuming LLM API credits or executing agent actions.

#### Step 2: Reject (Conditional)

```yaml
if: ${{ failure() && steps.authorize.outcome == 'failure' }}
```

**Effect:** If authorization fails, this step adds a ğŸ‘ reaction to the triggering issue or comment. This provides immediate visual feedback to the unauthorized user and to repository maintainers. It runs only on authorization failure â€” not on other step failures â€” using GitHub Actions' conditional execution model.

#### Step 3: Checkout

```yaml
uses: actions/checkout@v4
with:
  ref: ${{ github.event.repository.default_branch }}
  fetch-depth: 0
```

**Effect:** Checks out the repository's default branch with full git history (`fetch-depth: 0`). The full history is required because the agent may need to inspect prior commits, and the push-with-rebase conflict resolution strategy requires the complete commit graph. Checking out the default branch (rather than the event ref) ensures the agent always works from the canonical branch.

#### Step 4: Setup Bun

```yaml
uses: oven-sh/setup-bun@v2
with:
  bun-version: latest
```

**Effect:** Installs the Bun JavaScript/TypeScript runtime. Bun is the execution engine for both the lifecycle scripts (`indicator.ts`, `agent.ts`) and the dependency manager (`bun install`). Using `latest` ensures the workflow always runs on the most current stable release.

#### Step 5: Preinstall (indicator.ts)

```yaml
run: bun .github-minimum-intelligence/lifecycle/indicator.ts
```

**Effect:** Runs *before* dependency installation to provide immediate user feedback. The script adds a ğŸš€ (rocket) reaction to the triggering issue or comment, signaling "the agent is working on this." By running before `bun install`, the user sees the indicator within seconds of their action, even though dependency installation and agent execution may take minutes.

The script persists reaction metadata to `/tmp/reaction-state.json` so the later `agent.ts` step can add an outcome reaction (ğŸ‘ or ğŸ‘) without needing to re-derive which entity to react to. This is a cross-step state handoff using the filesystem as the communication channel.

#### Step 6: Install Dependencies

```yaml
run: cd .github-minimum-intelligence && bun install --frozen-lockfile
```

**Effect:** Installs the `@mariozechner/pi-coding-agent` package and its transitive dependencies from the lockfile. The `--frozen-lockfile` flag ensures reproducible builds â€” the exact versions committed in `bun.lock` are installed, preventing supply chain drift between runs.

#### Step 7: Run (agent.ts)

```yaml
run: bun .github-minimum-intelligence/lifecycle/agent.ts
```

**Effect:** This is the core execution step. The `agent.ts` orchestrator:

1. **Fetches** the issue title and body from the GitHub API (avoiding event payload truncation).
2. **Resolves or creates** a conversation session by checking `state/issues/<n>.json` for an existing session mapping.
3. **Validates** the configured LLM provider's API key is present, posting a helpful diagnostic comment if it is missing.
4. **Runs** the `pi` coding agent binary with the user's prompt and any prior session for context continuity.
5. **Extracts** the assistant's final text reply from the agent's JSONL output stream.
6. **Persists** the issue-to-session mapping and commits all changes (session transcript, mapping file, any agent-made file edits) to the repository.
7. **Pushes** changes back to the default branch with a retry-on-conflict loop (up to 3 attempts with rebase).
8. **Posts** the agent's reply as an issue comment, capped at 60,000 characters to respect GitHub's 65,535-character limit.
9. **Adds** an outcome reaction: ğŸ‘ on success, ğŸ‘ on error.

The environment variables passed to this step include API keys for seven LLM providers. Only the key matching the configured provider (in `.pi/settings.json`) needs to be set; the others are optional.

### Conditional Execution Guard

```yaml
if: >-
  (github.event_name == 'issues')
  || (github.event_name == 'issue_comment' && !endsWith(github.event.comment.user.login, '[bot]'))
```

**Effect:** The job-level condition prevents infinite loops. If the agent's own reply (posted as a comment by a `[bot]` user) triggered an `issue_comment` event, this guard stops the workflow from running again. Without this, the agent would respond to its own response indefinitely. The `endsWith(..., '[bot]')` pattern catches both GitHub App bots and Actions bots.

---

## 2. Agent Workflow (Template)

**File:** `.github-minimum-intelligence/install/github-minimum-intelligence-agent.yml`

**Effect:** This file is an identical copy of the agent workflow, stored inside the `.github-minimum-intelligence/install/` directory. During installation (via `setup.sh` or `MINIMUM-INTELLIGENCE-INSTALLER.ts`), this template is copied into the target repository's `.github/workflows/` directory.

This separation exists so that:

- The install template can be reset to defaults independently of any customizations a user has made to their live workflow.
- The `setup.sh` one-command installer can include the workflow without requiring the user to have a `.github/workflows/` directory pre-existing.
- The template serves as a canonical reference for what the "stock" workflow should look like.

---

## 3. Installation Workflow

**File:** `.github-minimum-intelligence/install/github-minimum-intelligence-installation.yml`

### Trigger Design

```yaml
on:
  installation:
    types: [created]
  installation_repositories:
    types: [added]
```

**Effect:** This workflow triggers when the GitHub Minimum Intelligence GitHub App is installed on a new account (`installation.created`) or when new repositories are added to an existing installation (`installation_repositories.added`). These are GitHub App-specific webhook events that only fire for repositories where the App has been installed.

### Permissions

```yaml
permissions:
  contents: read
```

**Effect:** The installation workflow requests only read access to contents. It does not need to write files â€” its sole purpose is to create a welcome issue. The `issues: write` permission is implicitly available through the GitHub App's own token (which has `issues: write` in its `app-manifest.json` configuration).

### Step Pipeline

#### Step 1: Log Installation

**Effect:** Logs the installation ID and the installing user's login to the Actions run log. This provides an audit trail of who installed the App and when, visible in the repository's Actions tab.

#### Step 2: Post Welcome Issue

**Effect:** Iterates over the repositories that were just added to the installation and creates a welcome issue in each one. The welcome issue contains:

- Confirmation that the App is installed.
- Instructions for adding the agent files (via `setup.sh` or manual copy).
- Instructions for adding an LLM API key as a repository secret.
- A prompt to start chatting by opening a new issue.

The script handles both `installation` events (where `github.event.repositories` lists all initial repos) and `installation_repositories` events (where `github.event.repositories_added` lists the newly-added repos). Error handling (`2>/dev/null || echo "âš ï¸ Could not create issue..."`) ensures a failure in one repository does not prevent welcome issues from being created in others.

---

## Design Principles

### 1. Issues as Interface

The entire user interaction model is built on GitHub Issues. Issues are the input mechanism (user writes a prompt), the output mechanism (agent replies as a comment), and the conversation threading model (each issue is a persistent session). This eliminates the need for any external UI, chat interface, or web application.

### 2. Git as Memory

Session transcripts are committed to the repository as JSONL files. The issue-to-session mapping is a JSON file committed alongside them. This means the agent's memory is versioned, auditable, and recoverable. Rolling back a conversation is a `git revert`. Inspecting what the agent knew at any point is a `git log`. There is no external database.

### 3. Actions as Runtime

GitHub Actions is the sole compute layer. There are no servers to provision, no containers to manage, no infrastructure to maintain. The workflow file *is* the deployment configuration. This is the "minimum" in Minimum Intelligence â€” the smallest possible infrastructure footprint for a functional AI agent.

### 4. Immediate Feedback via Reaction Signals

The ğŸš€ â†’ ğŸ‘/ğŸ‘ reaction pattern provides a three-state status indicator:

- ğŸš€ alone = the agent is working
- ğŸš€ + ğŸ‘ = the agent completed successfully
- ğŸš€ + ğŸ‘ = the agent encountered an error
- ğŸ‘ alone (no ğŸš€) = the user was not authorized

This is a lightweight status reporting system that requires no external monitoring and is visible directly in the GitHub UI next to the triggering issue or comment.

### 5. Security by Default

Authorization is the first step in the pipeline, before any code is checked out or any dependencies are installed. Unauthorized users are rejected before any compute resources are consumed beyond the authorization check itself. The bot-loop prevention guard ensures the system cannot consume resources in an infinite cycle.

### 6. Conflict-Resilient State Persistence

The push-with-retry strategy (up to 3 attempts with `git pull --rebase`) handles the case where multiple agent runs on different issues push to the same branch concurrently. Since each run modifies different files (different session files, different mapping files), rebasing resolves conflicts automatically in the vast majority of cases.

### 7. Template-Based Distribution

The install template pattern (storing a workflow template in the agent's own directory, then copying it during installation) enables a clean distribution model. Users get a working workflow without needing to understand or write YAML. The `setup.sh` script automates the entire process into a single command.

### 8. Onboarding Automation

The installation workflow transforms the GitHub App installation event into an actionable onboarding experience. Rather than requiring users to read documentation after installing, the system proactively creates a welcome issue with step-by-step setup instructions in every newly-added repository.

---

## Effect Summary

| Workflow | Primary Effect |
|----------|---------------|
| **Agent Workflow** | Transforms GitHub Issues into a bidirectional AI conversation interface with persistent memory, authorization control, and visual status feedback. |
| **Agent Workflow (Template)** | Enables zero-configuration distribution of the agent workflow to new repositories via the install script. |
| **Installation Workflow** | Automates onboarding by creating a welcome issue with setup instructions when the GitHub App is installed on a repository. |

Together, these workflows implement a complete AI agent lifecycle: **distribution** (installation workflow + template) â†’ **activation** (issue trigger) â†’ **authorization** (permission check) â†’ **execution** (agent pipeline) â†’ **persistence** (git commit/push) â†’ **response** (issue comment) â†’ **continuity** (session resume on next interaction).
